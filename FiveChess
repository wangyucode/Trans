package sample;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;

import java.net.InetAddress;
import java.net.UnknownHostException;

public class Controller implements NetService.NetStateChange, EventHandler<DialogEvent> {

    @FXML
    Canvas canvas;
    @FXML
    TextField tfIP;
    @FXML
    TextField tfMessage;
    @FXML
    TextArea taContent;
    @FXML
    Label lbIP;
    @FXML
    Button btnConnect;
    @FXML
    Button btnStart;
    @FXML
    Button btnSend;

    private GraphicsContext gc;
    private double gapX, gapY;
    private double chessSize;

    private NetService server;
    private NetService client;

    static final String HEAD_NET = "net";
    static final String BODY_OK = "ok";
    static final String HEAD_MSG = "msg";
    static final String HEAD_CHESS = "chess";
    static final String HEAD_GAME = "game";

    private boolean isOtherOK = true;


    private enum Chess {
        BLACK, WHITE
    }

    public enum NetType {
        SERVER, CLIENT
    }

    private enum Direction {
        TOP_LEFT, TOP, TOP_RIGHT, RIGHT, RIGHT_DOWN, DOWN, DOWN_LEFT, LEFT
    }

    static NetType netType;

    private Chess currentChess;
    private Chess[][] game = new Chess[21][21];

    @FXML
    protected void handleCanvasClicked(MouseEvent event) {

        if (netType == NetType.SERVER) {
            if (isOtherOK) {
                if (currentChess == Chess.BLACK) {
                    Position p = drawChess(currentChess, convertX(event.getX()), convertY(event.getY()));
                    if (game[p.x][p.y] == currentChess) {
                        return;
                    }
                    server.sendMessage(server.buildMessage(HEAD_CHESS, p.toString()));
                    taContent.appendText("[主机]走子：" + p.x + "，" + p.y + "\n");
                    currentChess = Chess.WHITE;
                    game[p.x][p.y] = Chess.BLACK;
                    checkWinner(p.x, p.y);
                } else {
                    taContent.appendText("[系统]请等待客户端走棋！\n");
                }
            } else {
                taContent.appendText("[系统]客户端还没有准备好！\n");
            }
        } else if (netType == NetType.CLIENT) {
            if (isOtherOK) {
                if (currentChess == Chess.WHITE) {
                    Position p = drawChess(currentChess, convertX(event.getX()), convertY(event.getY()));
                    if (game[p.x][p.y] == currentChess) {
                        return;
                    }
                    client.sendMessage(client.buildMessage(HEAD_CHESS, p.toString()));
                    taContent.appendText("[客户端]走子：" + p.x + "，" + p.y + "\n");
                    currentChess = Chess.BLACK;
                    game[p.x][p.y] = Chess.WHITE;
                    checkWinner(p.x, p.y);
                } else {
                    taContent.appendText("[系统]请等待主机走棋！\n");
                }
            } else {
                taContent.appendText("[系统]主机还没有准备好！\n");
            }
        }

    }

    private void checkWinner(int x, int y) {
        Chess thisChess = game[x][y];
        if (thisChess == null) {
            return;
        }

        int left2Right = 1 + countChessNum(Direction.LEFT, thisChess, x, y) + countChessNum(Direction.RIGHT, thisChess, x, y);
        System.out.println("left2Right=" + left2Right);
        if (left2Right >= 5) {
            win(thisChess);
            return;
        }

        int top2Down = 1 + countChessNum(Direction.TOP, thisChess, x, y) + countChessNum(Direction.DOWN, thisChess, x, y);
        System.out.println("top2Down=" + top2Down);
        if (top2Down >= 5) {
            win(thisChess);
            return;
        }

        int topLeft2RightDown = 1 + countChessNum(Direction.TOP_LEFT, thisChess, x, y) + countChessNum(Direction.RIGHT_DOWN, thisChess, x, y);
        System.out.println("topLeft2RightDown=" + topLeft2RightDown);
        if (topLeft2RightDown >= 5) {
            win(thisChess);
            return;
        }

        int topRight2DownLeft = 1 + countChessNum(Direction.TOP_RIGHT, thisChess, x, y) + countChessNum(Direction.DOWN_LEFT, thisChess, x, y);
        System.out.println("topRight2DownLeft=" + topRight2DownLeft);
        if (topRight2DownLeft >= 5) {
            win(thisChess);
        }
    }

    private void win(Chess thisChess) {
        isOtherOK = false;
        Alert alert = new Alert(Alert.AlertType.INFORMATION, thisChess == Chess.BLACK ? "黑棋获胜！" : "白棋获胜", ButtonType.OK);
        alert.show();
        currentChess = Chess.BLACK;
        alert.setOnCloseRequest(this);
    }

    @Override
    public void handle(DialogEvent event) {
        cleanChessBoard();
        if (netType == NetType.CLIENT) {
            client.sendMessage(client.buildMessage(HEAD_GAME, BODY_OK));
        } else {
            server.sendMessage(server.buildMessage(HEAD_GAME, BODY_OK));
        }
        game = new Chess[21][21];
    }


    private int countChessNum(Direction direction, Chess thisChess, int x, int y) {
        int num = 0;
        switch (direction) {
            case TOP_LEFT:
                if (x - 1 >= 0 && y - 1 >= 0 && thisChess == game[x - 1][y - 1]) {
                    num++;
                    num += countChessNum(direction, thisChess, x - 1, y - 1);
                }
                break;
            case TOP:
                if (y - 1 >= 0 && thisChess == game[x][y - 1]) {
                    num++;
                    num += countChessNum(direction, thisChess, x, y - 1);
                }
                break;
            case TOP_RIGHT:
                if (x + 1 <= 20 && y - 1 >= 0 && thisChess == game[x + 1][y - 1]) {
                    num++;
                    num += countChessNum(direction, thisChess, x + 1, y - 1);
                }
                break;
            case RIGHT:
                if (x + 1 <= 20 && thisChess == game[x + 1][y]) {
                    num++;
                    num += countChessNum(direction, thisChess, x + 1, y);
                }
                break;
            case RIGHT_DOWN:
                if (x + 1 <= 20 && y + 1 <= 20 && thisChess == game[x + 1][y + 1]) {
                    num++;
                    num += countChessNum(direction, thisChess, x + 1, y + 1);
                }
                break;
            case DOWN:
                if (y + 1 <= 20 && thisChess == game[x][y + 1]) {
                    num++;
                    num += countChessNum(direction, thisChess, x, y + 1);
                }
                break;
            case DOWN_LEFT:
                if (x - 1 >= 0 && y + 1 <= 20 && thisChess == game[x - 1][y + 1]) {
                    num++;
                    num += countChessNum(direction, thisChess, x - 1, y + 1);
                }
                break;
            case LEFT:
                if (x - 1 >= 0 && thisChess == game[x - 1][y]) {
                    num++;
                    num += countChessNum(direction, thisChess, x - 1, y);
                }
                break;
        }
        return num;
    }

    private double convertX(double x) {
        return gapX * ((int) ((x + gapX / 2) / gapX));
    }

    private double convertY(double y) {
        return gapY * ((int) ((y + gapY / 2) / gapY));
    }

    private Position drawChess(Chess chess, double x, double y) {
        switch (chess) {
            case BLACK:
                gc.setFill(Color.BLACK);
                gc.fillOval(x - chessSize / 2, y - chessSize / 2, chessSize, chessSize);
                break;
            case WHITE:
                gc.setFill(Color.WHITE);
                gc.fillOval(x - chessSize / 2, y - chessSize / 2, chessSize, chessSize);
                break;
        }
        return new Position((int) (x / gapX), (int) (y / gapY));
    }

    public void initialize() {
        gc = canvas.getGraphicsContext2D();
        gapX = canvas.getWidth() / 20;
        gapY = canvas.getHeight() / 20;
        chessSize = gapX * 0.8;
        cleanChessBoard();
        try {
            lbIP.setText("本机IP：" + InetAddress.getLocalHost().getHostAddress());
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }

    private void cleanChessBoard() {
        gc.setFill(Color.valueOf("#F5C26A"));
        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());
        gc.setStroke(Color.BLACK);
        for (int i = 1; i <= 19; i++) {
            gc.strokeLine(i * gapX, 0, i * gapX, canvas.getHeight());
            gc.strokeLine(0, i * gapY, canvas.getWidth(), i * gapY);
        }
    }

    @FXML
    protected void handleStartServer(ActionEvent event) {
        server = NetService.getInstance(NetType.SERVER);
        server.startServer();
        server.setNetStateChangeListener(this);
        netType = NetType.SERVER;
    }

    @FXML
    protected void handleConnectClicked(ActionEvent event) {

        if (tfIP.getText().matches("(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)")) {
            client = NetService.getInstance(NetType.CLIENT);
            client.setNetStateChangeListener(this);
            client.connectToServer(tfIP.getText());
            netType = NetType.CLIENT;
        }
    }

    @FXML
    protected void handleSendClicked(ActionEvent event) {
        if (tfMessage.getText().length() > 0) {
            if (netType == NetType.SERVER) {
                String message = server.buildMessage(HEAD_MSG, tfMessage.getText());
                server.sendMessage(message);
                taContent.appendText("[主机]" + tfMessage.getText() + "\n");
            } else if (netType == NetType.CLIENT) {
                String message = client.buildMessage(HEAD_MSG, tfMessage.getText());
                client.sendMessage(message);
                taContent.appendText("[客户端]" + tfMessage.getText() + "\n");
            }
        }
        tfMessage.setText("");
    }

    @Override
    public void onConnect() {
        System.out.println("some one connected");
        server.sendMessage(server.buildMessage(HEAD_NET, BODY_OK));
        taContent.appendText("[系统]客户端已连接！\n");
        tfMessage.setDisable(false);
        btnSend.setDisable(false);
        taContent.appendText("[系统]主机执黑棋，先走\n");
        currentChess = Chess.BLACK;
    }

    @Override
    public void onMessage(String message) {
        System.out.println(message);
        String[] msgArray = message.split(":");
        switch (msgArray[0]) {
            case HEAD_NET:
                if (msgArray[1].equals(BODY_OK)) {
                    taContent.appendText("[系统]已连接到主机！\n");
                    tfMessage.setDisable(false);
                    btnSend.setDisable(false);
                    tfIP.setDisable(true);
                    btnStart.setDisable(true);
                    btnConnect.setDisable(true);
                    taContent.appendText("[系统]客户端执白棋，请等待主机先走\n");
                }
                break;
            case HEAD_MSG:
                StringBuilder msgContent = new StringBuilder();
                for (int i = 1; i < msgArray.length; i++) {
                    msgContent.append(msgArray[i]);
                    if (i + 1 < msgArray.length) {
                        msgContent.append(':');
                    }
                }

                if (netType == NetType.SERVER) {
                    taContent.appendText("[客户端]" + msgContent.toString() + "\n");
                } else if (netType == NetType.CLIENT) {
                    taContent.appendText("[主机]" + msgContent.toString() + "\n");
                }
                break;
            case HEAD_CHESS:
                if (netType == NetType.SERVER) {
                    taContent.appendText("[客户端]走子：" + msgArray[1] + "," + msgArray[2] + "\n");
                    Position p = drawChess(Chess.WHITE, Double.parseDouble(msgArray[1]) * gapX, Double.parseDouble(msgArray[2]) * gapY);
                    game[p.x][p.y] = Chess.WHITE;
                    currentChess = Chess.BLACK;
                    checkWinner(p.x, p.y);
                } else if (netType == NetType.CLIENT) {
                    taContent.appendText("[主机]走子：" + msgArray[1] + "," + msgArray[2] + "\n");
                    Position p = drawChess(Chess.BLACK, Double.parseDouble(msgArray[1]) * gapX, Double.parseDouble(msgArray[2]) * gapY);
                    game[p.x][p.y] = Chess.BLACK;
                    currentChess = Chess.WHITE;
                    checkWinner(p.x, p.y);
                }
                break;
            case HEAD_GAME:
                isOtherOK = true;
                break;
        }
    }


    @Override
    public void onServerOK() {
        System.out.println("server OK");
        taContent.appendText("[系统]建主成功！\n");
        btnStart.setDisable(true);
        btnConnect.setDisable(true);
        tfIP.setDisable(true);
    }

    class Position {
        int x;
        int y;

        public Position(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public String toString() {
            return x + ":" + y;
        }
    }
}





package sample;

import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;


public class Main extends Application implements EventHandler<WindowEvent> {

    @Override
    public void start(Stage primaryStage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource("sample.fxml"));
        primaryStage.setTitle("五子棋");
        primaryStage.setScene(new Scene(root, 740, 520));
        primaryStage.setResizable(false);
        primaryStage.show();
        primaryStage.setOnCloseRequest(this);
    }


    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void handle(WindowEvent event) {
        try {
            NetService.getInstance(Controller.netType).close();
        } catch (Exception e) {
            //ignore this
        }
        System.exit(0);

    }
}



package sample;

import javafx.concurrent.Service;
import javafx.concurrent.Task;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

/**
 *
 */
public class NetService {

    private Socket socket;
    private InputStream is;
    private OutputStream os;
    private BufferedReader br;
    private PrintWriter pw;

    private NetStateChange nsc;

    private ServerSocket serverSocket;

    private static final int PORT = 1594;

    private static NetService client;
    private static NetService server;

    private NetService() {
    }

    public static NetService getInstance(Controller.NetType netType) {
        switch (netType) {
            case CLIENT:
                if (client == null) {
                    client = new NetService();
                }
                return client;
            case SERVER:
                if (server == null) {
                    server = new NetService();
                }
                return server;
            default:
                return server;
        }
    }


    public void startServer() {
        new ServerThread().start();
    }


    void connectToServer(String ip) {
        try {
            socket = new Socket(ip, PORT);
            init();
            startRead();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 初始化用于接收/发送的流处理
     *
     * @throws IOException
     */
    void init() throws IOException {
        is = socket.getInputStream();
        os = socket.getOutputStream();
        br = new BufferedReader(new InputStreamReader(is, "utf-8"));
        pw = new PrintWriter(new OutputStreamWriter(os, "utf-8"));
    }

    void startRead() {
        ReadThread reader = new ReadThread();
        reader.start();
    }

    public void sendMessage(String message) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                pw.println(message);
                pw.flush();
            }
        }).start();
    }

    public void close() {
        try {
//            br.close();
            pw.close();
            socket.close();
            if (Controller.netType == Controller.NetType.SERVER) {
                serverSocket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    interface NetStateChange {
        void onServerOK();

        void onConnect();

        void onMessage(String message);
    }

    public String readMessage() {
        String message = null;
        try {
            message = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return message;
    }

    String buildMessage(String head, String body) {
        return head + ':' + body;
    }


    void setNetStateChangeListener(NetStateChange nsc) {
        this.nsc = nsc;
    }

    class ServerThread extends Thread {
        @Override
        public void run() {
            while (true) {
                try {
                    serverSocket = new ServerSocket(PORT);
                    System.out.println(serverSocket.getInetAddress());
                    if (nsc != null) {
                        nsc.onServerOK();
                    }
                    socket = serverSocket.accept();
                    init();
                    if (nsc != null) {
                        nsc.onConnect();
                        nsc.onMessage(buildMessage(Controller.HEAD_NET, "some one connected!"));
                    }
                    startRead();
                    break;
                } catch (IOException e) {
                    System.out.print("Server failure\n");
                    e.printStackTrace();
                    try {
                        serverSocket.close();
                    } catch (IOException ex) {
                        //ignore this;
                    }
                }
            }
        }
    }

    class ReadThread extends Service<String> {

        @Override
        protected void succeeded() {
            super.succeeded();
            if (getValue() != null && getValue().length() > 0) {
                if (nsc != null) {
                    nsc.onMessage(getValue());
                }
            }
            this.restart();
        }

        @Override
        protected Task<String> createTask() {
            return new Task<String>() {
                protected String call() throws Exception {
                    return readMessage();
                }
            };
        }
    }
}




<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.geometry.Insets?>
<?import javafx.scene.canvas.Canvas?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Hyperlink?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>

<GridPane alignment="center" hgap="10" vgap="10" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="sample.Controller">
   <padding>
      <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
   </padding>
   <columnConstraints>
      <ColumnConstraints />
      <ColumnConstraints />
      <ColumnConstraints />
   </columnConstraints>
   <rowConstraints>
      <RowConstraints />
      <RowConstraints />
      <RowConstraints />
      <RowConstraints />
      <RowConstraints />
   </rowConstraints>
   <children>
      <Canvas fx:id="canvas" height="500.0" onMouseClicked="#handleCanvasClicked" width="500.0" GridPane.hgrow="ALWAYS" GridPane.rowSpan="5" />
      <Label fx:id="lbIP" prefWidth="200.0" text="本机IP：127.0.0.1" GridPane.columnIndex="1" GridPane.columnSpan="2" />
      <TextField fx:id="tfIP" promptText="请输入对方IP" GridPane.columnIndex="1" GridPane.rowIndex="1" />
      <Button fx:id="btnConnect" mnemonicParsing="false" onAction="#handleConnectClicked" text="连接" GridPane.columnIndex="2" GridPane.rowIndex="1" />
      <TextArea fx:id="taContent" editable="false" prefHeight="371.0" prefWidth="200.0" scrollLeft="2.0" scrollTop="2.0" wrapText="true" GridPane.columnIndex="1" GridPane.columnSpan="2" GridPane.hgrow="ALWAYS" GridPane.rowIndex="2" />
      <Hyperlink text="wycode.cn" GridPane.columnIndex="1" GridPane.columnSpan="2" GridPane.rowIndex="4" />
      <Button fx:id="btnStart" mnemonicParsing="false" onAction="#handleStartServer" text="建主" GridPane.columnIndex="2" />
      <TextField fx:id="tfMessage" disable="true" prefHeight="23.0" prefWidth="149.0" GridPane.columnIndex="1" GridPane.rowIndex="3" />
      <Button fx:id="btnSend" disable="true" mnemonicParsing="false" onAction="#handleSendClicked" text="发送" GridPane.columnIndex="2" GridPane.rowIndex="3" />
   </children>
</GridPane>

